function simulate_localize_SE()
% Simulateur + localisation + estimation D -> r (Stokes-Einstein)
% Unités : micromètres (um), secondes (s)
% Placez ce fichier dans simulate_localize_SE.m et lancez simulate_localize_SE

%% ---- Constantes physiques ----
kB = 1.380649e-23; % J/K

%% ---- Paramètres par défaut ----
params.magnification = 60.0;          % x60
params.pixel_size_sensor = 2.4;       % um
params.roi_size = 21;                 % pixels (impair)
params.lambda = 0.520;                % um (wavelength)
params.NA = 0.8;                      % numerical aperture
params.photons_per_frame = 800.0;
params.background = 5.0;              % photons/pixel
params.read_noise = 1.5;              % e- RMS
params.gain = 1.0;
params.rng_seed = 42;

rng(params.rng_seed);

%% ---- Scenario d'exemple ----
T_frames = 1000;
dt = 0.05;  % s
D_true = 0.5; % um^2/s

traj = simulate_trajectory(D_true, T_frames, dt);
traj = traj - mean(traj,1); % recentrer trajectoire autour de 0

% rendre et localiser
locs = zeros(T_frames,2);
images = cell(T_frames,1);
for i=1:T_frames
    frame = render_frame(traj(i,:), params);
    images{i} = frame;
    [x_abs, y_abs, sigma_r, A, offset, pcov] = localize_gaussian(frame, [], params.roi_size);
    % conversion pixel -> object plane (um)
    center_pix = (params.roi_size-1)/2.0;
    dx_pix = x_abs - center_pix;
    dy_pix = y_abs - center_pix;
    dx_um = dx_pix * params.pixel_size_sensor / params.magnification;
    dy_um = dy_pix * params.pixel_size_sensor / params.magnification;
    locs(i,:) = [dx_um, dy_um];
end

% compute msd
max_lag = 50;
[taus, msd] = compute_msd(locs, max_lag);

% fit msd linéaire
[D_hat, intercept, cov_beta, se_D] = fit_msd_linear(taus, msd, dt, 2);

% Stokes-Einstein conversion D -> r
D_hat_m2s = D_hat * 1e-12; % um^2/s -> m^2/s
T_kelvin = 293.15; % 20 °C
eta = 1.0e-3; % Pa·s
r_hat_m = kB * T_kelvin / (6 * pi * eta * D_hat_m2s);
r_hat_um = r_hat_m * 1e6;

sigma_D = se_D;
sigma_D_m2s = sigma_D * 1e-12;
if D_hat_m2s > 0
    sigma_r_m = (kB * T_kelvin / (6 * pi * eta)) * sigma_D_m2s / (D_hat_m2s^2);
else
    sigma_r_m = NaN;
end
sigma_r_um = sigma_r_m * 1e6;

% Affichage
fprintf('True D (um^2/s): %.4f\n', D_true);
fprintf('Estimated D_hat (um^2/s): %.6f +- %.6f\n', D_hat, sigma_D);
fprintf('Intercept (should reflect 4*sigma_loc^2) : %.6f\n', intercept);
fprintf('Estimated radius r (um): %.3f +- %.3f\n', r_hat_um, sigma_r_um);

% Plots
figure; plot(locs(:,1), locs(:,2), '-o', 'MarkerSize', 3); axis equal;
title('Trajectoire estimée (um)'); xlabel('x (um)'); ylabel('y (um)');

figure;
plot(taus*dt, msd, 'o'); hold on;
tfit = linspace(min(taus)*dt, max(taus)*dt, 100);
slope = (2*2)*D_hat; % 2*dim*D (dim=2)
plot(tfit, slope * tfit + intercept, '-');
xlabel('tau (s)'); ylabel('MSD (um^2)'); legend('MSD data','Fit'); title('MSD & fit');
grid on;

end

%% ----------------- Fonctions utilitaires -----------------

function g = gaussian2d_vec(p, X, Y)
% p = [A, x0, y0, sigma, offset]
A = p(1); x0 = p(2); y0 = p(3); sigma = p(4); offset = p(5);
g = A .* exp(-((X - x0).^2 + (Y - y0).^2) / (2*sigma^2)) + offset;
end

function [X, Y] = make_grid(roi_size)
% coordonnees centrees (matrice sry x srx)
coords = (0:roi_size-1) - (roi_size-1)/2;
[X, Y] = meshgrid(coords, coords);
end

function psf = psf_airy_on_pixel_grid(xc, yc, lambda, NA, M, pixel_size_sensor, roi_size)
[X, Y] = make_grid(roi_size);
r_pix = sqrt((X - xc).^2 + (Y - yc).^2);
pixel_size_obj = pixel_size_sensor / M; % um/pixel in object plane
r_obj = r_pix * pixel_size_obj; % um
k = 2 * pi * NA / lambda; % rad/um
v = k * r_obj;
Z = (2 * besselj(1, v) ./ v) .^ 2;
Z(v == 0) = 1; % limit as v -> 0
Zsum = sum(Z(:));
if Zsum == 0
    psf = ones(size(Z)) / numel(Z);
else
    psf = Z / Zsum;
end
end

function traj = simulate_trajectory(D, N_frames, dt)
% D in um^2/s, dt in s
sigma_step = sqrt(2 * D * dt);
steps = sigma_step .* randn(N_frames,2);
traj = cumsum(steps,1);
end

function frame = render_frame(position_um, params)
% position_um: [x,y] en um dans le plan objet, centre ROI est (0,0)
M = params.magnification;
pixel_size_sensor = params.pixel_size_sensor; % um
roi_size = params.roi_size;
lambda = params.lambda; % um
NA = params.NA;
photons_per_frame = params.photons_per_frame;
background = params.background;
read_noise = params.read_noise;

x_obj = position_um(1);
y_obj = position_um(2);
x_img_um = M * x_obj;
y_img_um = M * y_obj;
x_pix = x_img_um / pixel_size_sensor;
y_pix = y_img_um / pixel_size_sensor;

psf = psf_airy_on_pixel_grid(x_pix, y_pix, lambda, NA, M, pixel_size_sensor, roi_size);
expected = photons_per_frame * psf + background;

% Poisson shot noise (poissrnd) puis lecture bruit gaussien
try
    shot = poissrnd(expected); % requires Statistics Toolbox
catch
    % approximation gaussienne (ok si expected grand)
    shot = max(0, expected + sqrt(max(expected,0)) .* randn(size(expected)));
end
shot = double(shot) + read_noise .* randn(size(expected));
shot(shot < 0) = 0;
frame = shot;
end

function [x_abs, y_abs, sigma_r, A, offset, pcov] = localize_gaussian(image, roi_center, roi_size)
% Localise un pic par fit gaussien 2D sur une ROI centrée autour du max (ou roi_center)
% Retourne coords absolues en pixels (0-based apparent converti ci-dessous)

if nargin < 2 || isempty(roi_center)
    [~, idx] = max(image(:));
    [cy, cx] = ind2sub(size(image), idx);
else
    cx = round(roi_center(1));
    cy = round(roi_center(2));
end

half = floor((roi_size-1)/2);
[ny, nx] = size(image);
x0 = round(cx); y0 = round(cy);
x1 = max(1, x0 - half);
x2 = min(nx, x0 + half);
y1 = max(1, y0 - half);
y2 = min(ny, y0 + half);
roi = double(image(y1:y2, x1:x2));

[sry, srx] = size(roi);
[X, Y] = meshgrid((0:srx-1) - (srx-1)/2, (0:sry-1) - (sry-1)/2);

% initial guesses
A0 = max(roi(:)) - median(roi(:));
x0_guess = 0.0;
y0_guess = 0.0;
sigma_guess = 1.5;
offset0 = median(roi(:));
p0 = [A0, x0_guess, y0_guess, sigma_guess, offset0];

lb = [0, -5, -5, 0.2, 0];
ub = [Inf, 5, 5, 10, Inf];

ydata = roi(:);
pcov = NaN(5,5);

try
    if exist('lsqcurvefit','file') == 2
        opts = optimoptions('lsqcurvefit','Display','off','MaxFunctionEvaluations',5000);
        % lsqcurvefit expects fun(p,xdata) so on passe un xdata dummy (~) et on ignore
        fun = @(p,~) gaussian2d_lsq(p, srx, sry);
        pfit = lsqcurvefit(fun, p0, [], ydata, lb, ub, opts);
        pcov = NaN(5,5); % calcul de covariance demanderait jacobienne (non calculée ici)
    else
        error('lsqcurvefit not available');
    end
catch
    % fallback: centroid si le fit échoue ou toolbox absente
    total = sum(roi(:));
    if total <= 0
        x_abs = NaN; y_abs = NaN; sigma_r = NaN; A = NaN; offset = NaN; pcov = NaN(5,5);
        return;
    end
    sumx = sum(roi,1); % vector length srx
    sumy = sum(roi,2); % vector length sry
    cx_cent = sum( ((0:srx-1) - (srx-1)/2) .* sumx ) / total;
    cy_cent = sum( ((0:sry-1)' - (sry-1)/2) .* sumy ) / total;
    pfit = [A0, cx_cent, cy_cent, sigma_guess, offset0];
    pcov = NaN(5,5);
end

% Extraire paramètres et convertir en coordonnées absolues (pixels)
A = pfit(1); x0r = pfit(2); y0r = pfit(3); sigma_r = pfit(4); offset = pfit(5);
% x1,y1 sont indices MATLAB (1-based) du coin supérieur gauche du patch
% on veut le coordonnée en pixels relative à l'image (0-based style)
x_abs = (x1 - 1) + (x0r + (srx-1)/2);
y_abs = (y1 - 1) + (y0r + (sry-1)/2);

end

function y = gaussian2d_lsq(p, srx, sry)
% helper: return column vector correspondant à un patch de taille sry x srx
[X, Y] = meshgrid((0:srx-1) - (srx-1)/2, (0:sry-1) - (sry-1)/2);
y = gaussian2d_vec(p, X, Y);
y = y(:);
end

function [taus, msd] = compute_msd(positions, max_lag)
% positions Nx2 en um
N = size(positions,1);
if nargin < 2 || isempty(max_lag)
    max_lag = floor(N/4);
end
msd = zeros(max_lag,1);
for lag = 1:max_lag
    diffs = positions(lag+1:end,:) - positions(1:end-lag,:);
    sq = sum(diffs.^2,2);
    msd(lag) = mean(sq);
end
taus = (1:max_lag)';
end

function [D_hat, intercept, cov_beta, se_D] = fit_msd_linear(taus, msd, dt, dim)
% Fit msd = 2*dim*D*t + C
t = taus * dt;
X = [t ones(size(t))];
beta = X \ msd;
slope = beta(1); intercept = beta(2);
n = length(msd);
if n > 2
    residuals = msd - X*beta;
    sigma2 = sum(residuals.^2) / (n - 2);
    cov_beta = sigma2 * inv(X'*X);
else
    cov_beta = NaN(2,2);
end
D_hat = slope / (2*dim);
if ~any(isnan(cov_beta(:)))
    se_slope = sqrt(cov_beta(1,1));
    se_D = se_slope / (2*dim);
else
    se_D = NaN;
end
end
