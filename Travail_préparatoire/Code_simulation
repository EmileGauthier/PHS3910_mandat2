% Ça part!!!!!

% Étape 1 - Simuler le mouvement / position d'une particule (une position
% par time frame, puis nouvelle simulation de la position pour un nouveau time frame)
% Ici le mouvement brownien dépend de D théorique (qu'on fixe)
% Pourrait direct retourner un vecteur avec les N positions xy de
% l'expérience (par ex N = 100, on a les 100 positions)

% Étape 2 - Simuler une photo réaliste à partir de cette position
% (connaissant cette position) --> PSF  et Poisson. 

% Étape 3 - Fit gaussien pour trouver la position expérimentale de la
% particule, pour chaque photo

% Étape 4 - Avec toutes les positions sur toutes les photos, calculer le
% MSD

% Étape 5 - Avec le MSD, estimer D puis r la taille de la particule

% Étape 6 - Contraste et résolution

% Étape 7 - Paramètres à varier, structure générale qui fait appel à toutes
% ces fonctions. 


% =========================================================================

% Code : 

% Étape 1 : simuler la position d'une particule en mouvement brownien. 

% 1.1 - Coefficient de diffusion D théorique (pour simuler le mouvement)
r_real = 1E-6 ; % Taille réelle de la particule

k_b = 1.380649E-23 ; % Constante de Boltzmann (J/K)
temp = 293 ; % Température absolue du fluide (K)
eta = 1E-3 ; % Viscosité dynamique du fluide
% La viscosité dynamique de l'eau est environ 0,001 Pa * s à 20°C.
D_real = (k_b * temp) / (6 * pi * eta * r_real) ; % Coefficient de diffusion (m^2/s)

delta_t = 0.1e-3 ; % Délai entre chaque frame (1 ms entre chaque frame?)

grossissement = 20; % Magnification du système optique
NA = 1.33; % Ouverture numérique
lmda = 500e-9; % Longueur d'onde captée (m)
pixel_camera = 1.55e-6; % Taille du pixel (m)
n_pixels_camera = [4056;3040]; % Dimensions du détecteur (pixel)

pixel_objet = pixel_camera / grossissement; % Taille du pixel dans l'espace objet

% Maillage dans l'espace image
x_im = 0:pixel_camera:(n_pixels_camera(1)-1)*pixel_camera;
y_im = 0:pixel_camera:(n_pixels_camera(2)-1)*pixel_camera;
[X_im,Y_im] = meshgrid(x_im,y_im);

% 1.2 - Mouvement brownien pour chaque frame : 

function [x2, y2] = brownien(x1, y1, D_real, delta_t)

% Définition de la fonction "brownien" : 
%   Paramètres sortie : x2 et y2 les coordonnées réelles de la particule.
%   Paramètres entrée : x1 et y1 les coordonnées initiales de la particule;
%                       D le coefficient de diffusion théorique;
%                       delta_t le temps entre chaque frame;
%                       

% X = randn retourne un scalaire à partir de la distribution normale


% Calculer les déplacements aléatoires en fonction du coefficient de diffusion
sigma = sqrt(2 * D_real * delta_t); % Écart type du mouvement brownien
x2 = x1 + sigma * randn; % Nouvelle position x
y2 = y1 + sigma * randn; % Nouvelle position y

end 

N = 1000; % Nombre de pas de temps à simuler
x_positions = zeros(1, N); % Initialiser le vecteur des positions x
y_positions = zeros(1, N); % Initialiser le vecteur des positions y
x_positions(1) = 0; % Position initiale x, mettons 0.
y_positions(1) = 0; % Position initiale y, mettons 0.

for i = 2:N
    [x_positions(i), y_positions(i)] = brownien(x_positions(i-1), y_positions(i-1), D_real, delta_t);
end

% -------------------------------------------------------------------------

% Étape 2 - Simuler une photo réaliste à partir de cette position
% (connaissant cette position) --> PSF  et Poisson.

function psf = psf_convolve(x, y, X_im, Y_im, NA, lmda)
%   Paramètres sorties : psf - Maillage 2D correspondant à la convolution
%   du delta Dirac à la position x,y avec la fonction psf.
    r = sqrt((X_im - x).^2 + (Y_im - y).^2);
    temp = (2 .* pi .* NA .* r)./lmda;
    psf = (2*besselj(1,temp) ./ temp).^2;

end

% psf = psf_convolve(100*pixel_camera,200*pixel_camera,X_im,Y_im,NA,lmda);
% mesh(X_im(150:250,50:150),Y_im(150:250,50:150),psf(150:250,50:150))

function intensity_mesh = intensity_mesh_fun(x, y, NA, lambda, X_im, Y_im)
 
%   Paramètres sortie : psf - Maillage 2d de l'intensité
%   Paramètres entrée : x et y - Coordonnées réelles de la particule.
%                       D le coefficient de diffusion théorique;
%                       delta_t le temps entre chaque frame;
%    

    % 2.2 - Générer la PSF discrétisée sur la grille, avec la formule puis
    % la convolution

    % 2.3 -  Bruit de Poisson


end

% ===================================================================

% 3.1 - Fonction qui estime l'écart-type pour le guess initial du fit
% gaussien à partir des données brutes

function s0 = sigma_from_fwhm(X, Y, Z, xc, yc) % xc et yc les coordonnées du centre --> x0_0 et y0_0.
  % Z should have background subtracted if needed
  half = max(Z(:))/2;
  % x-profile (take nearest row to yc)
  [~, iy] = min(abs(Y(:,1) - yc));
  xprof = X(iy,:);
  zxp = Z(iy,:);
  sx = fwhm_to_sigma(xprof, zxp, half);

  % y-profile (take nearest column to xc)
  [~, ix] = min(abs(X(1,:) - xc));
  yprof = Y(:,ix);
  zyp = Z(:,ix);
  sy = fwhm_to_sigma(yprof, zyp, half);
  s0 = [sx, sy]; % Jsp pourquoi ça output pas sans ça...
end

function sigma = fwhm_to_sigma(coord, profile, half)
  % interpolate to find half-maximum crossing points
  % ensure monotonic around peak by searching left/right from max
  [~, imax] = max(profile);
  % left crossing
  xl = interp1(profile(1:imax), coord(1:imax), half, 'linear');
  % right crossing
  xr = interp1(profile(imax:end), coord(imax:end), half, 'linear');
  fwhm = xr - xl;
  sigma = fwhm / (2*sqrt(2*log(2))); % = fwhm / 2.35482
end

% 3.2 - Le vrai fit gaussien
function params = fit2DGaussian(X, Y, Z)
%FIT2DGAUSSIAN  Fit a 2D Gaussian by nonlinear least squares.
%Ce code a été généré par chatgpt.
%
%   params = fit2DGaussian(X, Y, Z)
%
% Inputs:
%   X, Y : coordinate matrices (as from meshgrid)
%   Z    : data matrix (same size as X,Y)
%
% Output:
%   params = [A, x0, y0, sx, sy, offset]
%     where the fitted model is:
%       Zfit = A * exp( -((X - x0).^2/(2*sx^2) + (Y - y0).^2/(2*sy^2)) ) + offset
%
% Requires Optimization Toolbox (for lsqcurvefit).

    % Initial guesses (reasonable defaults)
    A0       = max(Z(:)) - min(Z(:)); % Guess l'amplitude comme l'écart max d'intensité
    offset0  = min(Z(:)); % offset = bruit --> valeur min
    [~, idx] = max(Z(:)); % estime le centre comme la position au pixel max, avec [~, idx] une notation compacte pour avoir juste l'indice.
    x0_0     = X(idx);
    y0_0     = Y(idx);
    % Estimations initiales des std : 

    s0 = sigma_from_fwhm(X, Y, Z, x0_0, y0_0);
    sx0 = s0(1);
    sy0 = s0(2);

    % Mais on sait pour une gaussienne que fwhm = 2sqrt(2ln2) std_1D !!!
    % De ce que j'en comprends, tant qu'on a un bon guess initial, on a des
    % bonnes chances de converger vers la vraie solution (plutôt qu'un
    % minimum local), donc même s'il propose une autre méthode avec les
    % deuxième moments, ça devrait être chill. 

    p0 = [A0, x0_0, y0_0, sx0, sy0, offset0];

    % Mettre les données dans le format voulu pour lsqcurvefit
    xdata = [X(:), Y(:)];
    zdata = Z(:);

    % Define 2D Gaussian model
    gauss2d = @(p, xy) p(1) * exp( ...
        -((xy(:,1) - p(2)).^2 / (2*p(4)^2) + (xy(:,2) - p(3)).^2 / (2*p(5)^2)) ) + p(6);

    % Déclare ses variables p (paramètres) et xy (coordonnées où on évalue
    % la gaussienne 2D). 
    
    % Perform least-squares fit
    options = optimoptions('lsqcurvefit','Display','off'); % Turn off verbose output. You can change 'Display' for diagnostics.
    lb = [0, -inf, -inf, 0, 0, -inf]; % Lower bounds sur les paramètres : amplitude ≥ 0, widths ≥ 0. Centers unconstrained, offset unconstrained (can be negative).
    ub = [inf, inf, inf, inf, inf, inf]; % Bornes supérieures : on s'en fout!

    params = lsqcurvefit(gauss2d, p0, xdata, zdata, lb, ub, options);
end

% ------------------------------------------------------------------

% Exemple : 

% Create synthetic data
[X, Y] = meshgrid(-5:0.2:5, -5:0.2:5); % Nous aussi il nous faudra ça mais une grille de pixels
%Ztrue = 3 * exp(-((X-1).^2/(2*1.2^2) + (Y+0.5).^2/(2*0.8^2))) + 0.5;
%Z = Ztrue + 0.05*randn(size(Ztrue));  % add some noise

% Fit
params = fit2DGaussian(X, Y, Z);

% Plot result
Zfit = params(1) * exp(-((X - params(2)).^2/(2*params(4)^2) + (Y - params(3)).^2/(2*params(5)^2))) + params(6);

figure;
subplot(1,2,1); surf(X, Y, Z); title('Data');
subplot(1,2,2); surf(X, Y, Zfit); title('Fitted Gaussian');

% ========================================================================
